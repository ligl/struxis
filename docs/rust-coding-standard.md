# Rust 代码规范（团队约定）

> 目的：保证代码长期可维护，并满足当前项目目标：低延时、高并发、无锁设计优先、零成本抽象。

## 1. 强制原则

1. 符合 Rust 官方风格（rustfmt + idiomatic Rust）。
2. 先正确，再优化；优化必须可解释、可验证。
3. 公共 API 必须有文档注释（`///`），模块必须有职责注释（`//!`）。
4. 变更必须可验证：至少 `cargo check`，关键改动需对应测试。
5. 全项目建模遵循“专业交易员视觉语义优先”：尽量少用或不用阈值/参数驱动结构判定。

## 2. 命名与可见性

- 类型/trait：`CamelCase`
- 函数/模块/变量：`snake_case`
- 常量：`SCREAMING_SNAKE_CASE`
- 可见性最小化：默认私有，仅在必要时 `pub`
- 语义优先：名字应直接表达职责，避免无意义后缀

## 3. 错误处理

- 业务路径优先 `Result<T, E>`，错误类型语义清晰。
- 禁止在生产路径滥用 `unwrap/expect`（测试中可用）。
- 错误信息需可定位（包含上下文）。

## 4. 并发与性能

- 优先无锁或低锁竞争结构；锁粒度最小化。
- 避免不必要的分配、克隆、字符串拼接。
- 默认使用零成本抽象：迭代器、泛型、内联友好接口。
- 共享状态必须明确线程安全边界。

## 5. API 与模块设计

- 模块单一职责，边界清晰。
- 公共 API 保持稳定、最小、可组合。
- 配置入口集中（如 `*Config`），避免参数散落。
- 分层约束：`struxis` 仅承担 `infra/market/analysis`，决策与执行放在 `strategy` crate。

## 5.1 视觉语义优先（全项目）

- 适用范围：`struxis`、`market`、`strategy`、`runtime`、`apps` 及后续新增模块。
- 默认策略：先使用结构关系、顺序约束、状态机语义表达规则，不依赖经验阈值。
- 阈值使用条件：仅在无法用结构语义表达且有明确数据证据时允许引入，并需给出：
	- 引入理由（为什么必须参数化）
	- 可回放验证（至少一个回归样本）
	- 失效边界（参数在哪些行情下不可靠）
- 调参原则：优先“减参/去参”，禁止把阈值当作常规修复手段。

## 6. 文档与测试

- 公共结构体、枚举、函数都应有用途说明。
- 复杂行为（并发、背压、顺序语义）必须有测试覆盖。
- 文档示例应可执行或接近可执行。

## 7. 提交前检查（最小）

```bash
cargo check --workspace
cargo test -p market
```

如改动跨 crate，按影响范围补充对应测试。
